<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: extracted_scripts.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: extracted_scripts.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
// Extracted from fetch_and_display.html

        /**
         * Determines if the strip is using WS2812 or APA102.
         * @type {boolean}
         */
        let ws_strip = true; //using ws2812 or APA102?
        /**
         * Variable to store the original pattern.
         * @type {string|number}
         */
        let originalPattern; // Variable to store the original pattern

        /**
         * Reference to the delete button element.
         * @type {HTMLElement}
         */
        const deleteButton = document.getElementById('deleteButton');

        //globals for ip scan:
        /**
         * Reference to the spinner element.
         * @type {HTMLElement}
         */
        const spinner = document.getElementById('spinner');
        /**
         * Reference to the counter element.
         * @type {HTMLElement}
         */
        const counter = document.getElementById('counter');
        /**
         * Reference to the current IP span element.
         * @type {HTMLElement}
         */
        const currentIPSpan = document.getElementById('currentIP');

        /**
         * Default number of pixels.
         * @type {number}
         */
        let number_of_pixels = 120; // Default Number of Pixels
        /**
         * Default Main Poi IP (AP Mode).
         * @type {string}
         */
        let poi_one_ip = "192.168.1.1"; // Default Main Poi IP (AP Mode)
        // const poi_one_ip = "10.0.0.5"
        /**
         * Default Auxillary Poi IP (AP Mode).
         * @type {string}
         */
        const poi_two_ip = "192.168.1.78"; // Default Auxillary Poi IP (AP Mode)

        /**
         * Updates the pixel size based on the input value.
         */
        function updatePixelSize() {
            const pixelInput = document.getElementById('pixelInput').value;
            number_of_pixels = parseInt(pixelInput, 10);
            document.getElementById('currentPx').textContent = `Current px: ${number_of_pixels}`;
            // Update the images with the new pixel size if necessary
        }

        // Function to create black placeholder images
        /**
         * Creates black placeholder images in the specified container.
         * @param {string} containerId - The ID of the container to append images to.
         * @param {string} ip - The IP address of the POI.
         */
        function createBlackImages(containerId, ip) {
            const container = document.getElementById(containerId);

            // Loop through characters and create image elements
            for (let i = 0; i &lt; 62; i++) {
                const char = getCharFromIndex(i);
                const fileName = char + '.bin'; // Add ".bin" extension

                try {
                    // Create image element
                    const imgElement = document.createElement('img');
                    imgElement.className = 'black-image'; // Add class for styling
                    imgElement.alt = fileName; // Set alt attribute with filename
                    imgElement.style.width = `${number_of_pixels}px`; // Set width
                    imgElement.style.height = `${number_of_pixels}px`; // Set height

                    // Attach click event listener to the image element
                    imgElement.addEventListener('click', function () {
                        decompressAndDisplay(ip, fileName);
                        // displayImageInModal(imgElement.src, imgElement.alt);
                    });

                    // Attach dragover and drop event listeners to the image element
                    imgElement.addEventListener('dragover', function (event) {
                        event.preventDefault();
                    });

                    imgElement.addEventListener('drop', function (event) {
                        event.preventDefault();
                        // Accessing the first file from the dropped files
                        const droppedFile = event.dataTransfer.files[0];
                        const draggedFileBlob = droppedFile ? URL.createObjectURL(droppedFile) : '';
                        const imageName = imgElement.alt;
                        try {
                            // uploadDraggedFile(draggedFileBlob, imageName, ip);
                            // imgElement.src = draggedFileBlob;
                            uploadDraggedFile(draggedFileBlob, imageName, ip).then((success) => {
                                if (success) {
                                    console.log("dragging succeeded? replacing image");
                                    imgElement.src = draggedFileBlob;
                                }
                            }).catch((error) => {
                                console.error('Error uploading: ', error);
                            });
                        } catch (error) {
                            console.error('Error uploading: ', error);
                        }
                    });

                    // Append image element to container
                    container.appendChild(imgElement);
                } catch (error) {
                    console.error('Error creating image:', error);
                }
            }
        }

        // Call the function to create black images:
        createBlackImages('imageContainer', poi_one_ip);
        createBlackImages('imageContainertwo', poi_two_ip);

        /**
         * Increases the brightness of the image.
         * @param {string} imageUrl - The URL of the image to modify.
         * @param {number} brightnessAmount - The amount to increase the brightness by.
         * @returns {Promise&lt;string>} - The URL of the modified image.
         */
        async function increaseBrightness(imageUrl, brightnessAmount) {
            return new Promise((resolve, reject) => {
                Jimp.read(imageUrl, (err, image) => {
                    if (err) {
                        reject(err);
                    } else {
                        // Increase the brightness by the specified amount
                        image.brightness(brightnessAmount);

                        // Get the base64 representation of the modified image
                        image.getBase64Async(Jimp.MIME_PNG)
                            .then(modifiedImageUrl => {
                                resolve(modifiedImageUrl);
                            })
                            .catch(error => {
                                reject(error);
                            });
                    }
                });
            });
        }


        /**
         * Rotates the image by 90 degrees.
         * @param {string} imageUrl - The URL of the image to rotate.
         * @returns {Promise&lt;string>} - The URL of the rotated image.
         */
        async function rotateImage90(imageUrl) {
            return new Promise((resolve, reject) => {
                Jimp.read(imageUrl, (err, image) => {
                    if (err) {
                        reject(err);
                    } else {
                        // Rotate the image by -90 degrees
                        image.rotate(90).getBase64Async(Jimp.MIME_PNG)
                            .then(rotatedImageUrl => {
                                resolve(rotatedImageUrl);
                            })
                            .catch(error => {
                                reject(error);
                            });
                    }
                });
            });
        }

        /**
         * Decompresses the binary data into an image.
         * @param {Uint8Array} binaryData - The binary data to decompress.
         * @returns {Promise&lt;string>} - The URL of the decompressed image.
         */
        async function decompress(binaryData) {
            console.log("Decompress started");
            const width = number_of_pixels;
            const height = Math.ceil(binaryData.length / width);
            console.log("Height is: " + height);
            // Create a new Jimp image with the specified width and height
            const decompressedImage = new Jimp(width, height);

            let dataIndex = 0;

            // Iterate through each pixel and decompress
            for (let y = 0; y &lt; height; y++) {
                for (let x = 0; x &lt; width; x++) {
                    // Ensure we don't exceed the length of the binaryData
                    if (dataIndex &lt; binaryData.length) {
                        const encodedValue = binaryData[dataIndex];

                        // Decode the encoded value to extract RGB components
                        const r = ((encodedValue &amp; 0xE0) >> 5) &lt;&lt; 3; // Red component
                        const g = ((encodedValue &amp; 0x1C) >> 2) &lt;&lt; 3; // Green component
                        const b = (encodedValue &amp; 0x03) &lt;&lt; 6; // Blue component

                        // Set the pixel color in the decompressed image
                        decompressedImage.setPixelColor(Jimp.rgbaToInt(r, g, b, 255), x, y);

                        dataIndex++; // Move to the next encoded value
                    } else {
                        // If we run out of data, break the loop
                        break;
                    }
                }
            }

            // Convert the decompressed image to a data URL
            const imageUrl = await decompressedImage.getBase64Async(Jimp.MIME_PNG);

            return imageUrl;
        }




        /**
         * Fetches data from the specified URL with retries.
         * @param {string} url - The URL to fetch data from.
         * @returns {Promise&lt;Response>} - The response object.
         */
        async function fetchDataWithRetry(url) {
            console.log("fetching...");
            const maxRetries = 3; // Maximum number of retries
            let retries = 0; // Initialize the number of retries
            while (retries &lt; maxRetries) {
                try {
                    console.log(retries);
                    const response = await fetch(url);
                    if (!response.ok) {
                        // throw new Error(`Failed to fetch image: ${response.statusText}`);
                        console.log("not able to get image, should retry now?");
                    }
                    // Return response if successful
                    console.log(`got response for ${url} : ${response}`);
                    return response;
                } catch (error) {
                    console.error('Error fetching image:', error);
                    retries++; // Increment the retry count
                    console.log(`Retrying... Attempt ${retries}/${maxRetries}`);
                }
            }
            // If all retries fail, throw an error
            throw new Error(`Failed to fetch image after ${maxRetries} attempts`);
        }

        // DISPLAY IMAGES FROM POI CODE HERE: 
        let retryCount = 0;
        const MAX_RETRY_COUNT = 3;

        /**
         * Decompresses and displays the image from the specified IP and file name.
         * @param {string} ip - The IP address of the POI.
         * @param {string} fileName - The name of the file to decompress and display.
         */
        async function decompressAndDisplay(ip, fileName) {
            try {
                let response;
                try {
                    // response = await fetch(`http://${ip}/edit?file=${fileName}`);
                    response = await fetchDataWithRetry(`http://${ip}/edit?file=${fileName}`);
                    // if (!response.ok) {
                    //     throw new Error(`Failed to fetch image: ${response.statusText}`);
                    // }
                } catch (error) {
                    console.error("error fetching data for: " + fileName + " ", error);
                    throw error;
                } finally {

                    const arrayBuffer = await response.arrayBuffer();
                    if (arrayBuffer) {
                        console.log("arrayBuffer for : " + fileName + " " + arrayBuffer);
                    } else {
                        console.log("NO ARRAYBUFFER!" + fileName + " ");
                    }

                    const binaryData = new Uint8Array(arrayBuffer);
                    if (binaryData) {
                        console.log("binaryData: " + fileName + " " + binaryData);
                    } else {
                        console.log("NO BINARYDATA!" + fileName + " ");
                    }
                    const imageUrl = await decompress(binaryData);
                    if (imageUrl) {
                        console.log("imageUrl: " + fileName + " " + imageUrl);
                    } else {
                        console.log("NO IMAGEURL!" + fileName + " ");
                    }


                    // Rotate the decompressed image
                    let rotatedImageUrl;
                    try {
                        rotatedImageUrl = await rotateImage90(imageUrl);
                    } catch (error) {
                        console.error('error rotating:', error);
                        throw error;
                    } finally {



                        // Create a new image element
                        const imgElement = document.createElement('img');
                        imgElement.src = rotatedImageUrl; // Set the src attribute with the rotated image URL
                        imgElement.alt = fileName; // Set the alt attribute with the file name

                        // Attach click event listener to the image element
                        imgElement.addEventListener('click', function () {
                            displayImageInModal(imgElement.src, imgElement.alt);
                        });

                        // Attach dragover and drop event listeners to the image element
                        imgElement.addEventListener('dragover', function (event) {
                            event.preventDefault();
                        });

                        imgElement.addEventListener('drop', function (event) {
                            event.preventDefault();
                            // Accessing the first file from the dropped files
                            const droppedFile = event.dataTransfer.files[0];
                            const draggedFileBlob = droppedFile ? URL.createObjectURL(droppedFile) : '';
                            const imageName = imgElement.alt;
                            // displayDraggedFileDetails(draggedFilePath, imageName);
                            uploadDraggedFile(draggedFileBlob, imageName, ip).then((success) => {
                                if (success) {
                                    imgElement.src = draggedFileBlob;
                                }
                            }).catch((error) => {
                                console.error('Error uploading: ', error);
                            });
                            // uploadDraggedFile(draggedFileBlob, imageName, ip);
                            // imgElement.src = draggedFileBlob;
                        });

                        let containerId;

                        if (ip === poi_two_ip) {
                            containerId = 'imageContainertwo';
                        } else {
                            containerId = 'imageContainer';
                        }

                        const container = document.getElementById(containerId);

                        // Append the image element to the container
                        // container.appendChild(imgElement);

                        //replace images: 
                        const images = container.querySelectorAll('img'); // Get all img elements in the container

                        images.forEach(img => {
                            if (img.alt === fileName) {
                                // Create a new image element
                                // const newImgElement = document.createElement('img');
                                // newImgElement.src = newSrc; // Set the src attribute with the new image URL
                                // newImgElement.alt = fileName; // Set the alt attribute with the file name

                                // Replace the old image with the new one
                                img.parentNode.replaceChild(imgElement, img);
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Error decompressing and displaying image: ' + fileName, error);
                if (retryCount &lt; MAX_RETRY_COUNT) {
                    retryCount++;
                    decompressAndDisplay(ip, fileName); // Retry
                } else {
                    console.error('Max retry count exceeded. Unable to decompress and display image: ' + fileName);
                    retryCount = 0;
                    //create placeholder image: 
                    try {
                        let containerId_replace;

                        if (ip === poi_two_ip) {
                            containerId_replace = 'imageContainertwo';
                        } else {
                            containerId_replace = 'imageContainer';
                        }

                        const container_replace = document.getElementById(containerId_replace);
                        // Create image element - blank image on fail
                        const imgElementReplacement = document.createElement('img');
                        imgElementReplacement.className = 'black-image'; // Add class for styling
                        imgElementReplacement.alt = fileName; // Set alt attribute with filename

                        // Attach click event listener to the image element
                        imgElementReplacement.addEventListener('click', function () {
                            decompressAndDisplay(ip, fileName);
                            // displayImageInModal(imgElementReplacement.src, imgElementReplacement.alt);
                        });

                        // Attach dragover and drop event listeners to the image element
                        imgElementReplacement.addEventListener('dragover', function (event) {
                            event.preventDefault();
                        });

                        imgElementReplacement.addEventListener('drop', function (event) {
                            event.preventDefault();
                            // Accessing the first file from the dropped files
                            const droppedFileReplacement = event.dataTransfer.files[0];
                            const draggedFileBlobReplacement = droppedFileReplacement ? URL.createObjectURL(droppedFileReplacement) : '';
                            const imageNameReplacement = imgElementReplacement.alt;
                            // displayDraggedFileDetails(draggedFilePath, imageName);
                            uploadDraggedFile(draggedFileBlobReplacement, imageNameReplacement, ip).then((success) => {
                                if (success) {
                                    imgElementReplacement.src = draggedFileBlobReplacement;
                                }
                            }).catch((error) => {
                                console.error('Error uploading: ', error);
                            });
                            // uploadDraggedFile(draggedFileBlobReplacement, imageNameReplacement, ip);
                            // imgElementReplacement.src = draggedFileBlobReplacement;
                        });

                        // Append image element to container
                        // container_replace.appendChild(imgElementReplacement);

                        const imagestwo = container_replace.querySelectorAll('img'); // Get all img elements in the container

                        imagestwo.forEach(img => {
                            if (img.alt === fileName) {
                                img.parentNode.replaceChild(imgElementReplacement, img);
                            }
                        });
                    } catch (error) {
                        console.error('Error creating image:', error);
                    }
                }
            }
        }

        

        /**
         * Displays the image in a modal.
         * @param {string} imageSrc - The URL of the image to display.
         * @param {string} imageName - The name of the image.
         */
        function displayImageInModal(imageSrc, imageName) {
            // Clear existing modal if any
            clearModal();
            // Create a modal overlay
            const modalOverlay = document.createElement('div');
            modalOverlay.classList.add('modal-overlay');

            // Create a modal container
            const modalContainer = document.createElement('div');
            modalContainer.classList.add('modal-container');

            // Create an image element for the modal
            const modalImage = document.createElement('img');
            modalImage.style.width = '200%'; // Zoom the image to 200% - todo: not working!
            modalImage.src = imageSrc;

            // Create a paragraph element for the filename
            const filenameParagraph = document.createElement('p');
            filenameParagraph.textContent = imageName;

            // Create a delete button
            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Delete';

            // Add click event listener to the delete button
            deleteButton.addEventListener('click', () => {
                const ipAddresses = [poi_one_ip, poi_two_ip];
                ipAddresses.forEach(ip => {
                    deleteFile(ip, imageName);
                });
            });

            // Append the image, filename paragraph, and delete button to the modal container
            modalContainer.appendChild(modalImage);
            modalContainer.appendChild(filenameParagraph);
            modalContainer.appendChild(deleteButton);

            // Append the modal container to the modal overlay
            modalOverlay.appendChild(modalContainer);

            // Append the modal overlay to the body
            document.body.appendChild(modalOverlay);

            // Add a click event listener to close the modal when clicked outside the image
            modalOverlay.addEventListener('click', function () {
                clearModal();
            });
        }

        


        /**
         * Clears the modal overlay.
         */
        function clearModal() {
            const modalOverlay = document.querySelector('.modal-overlay');
            if (modalOverlay) {
                modalOverlay.remove();
            }
        }

        /**
         * Displays details of the dragged file.
         * @param {string} filePath - The path of the dragged file.
         * @param {string} imageName - The name of the image.
         */
        function displayDraggedFileDetails(filePath, imageName) {
            alert("File path of the dragged image: " + filePath + "\nFilename of the image it was dragged onto: " + imageName);
        }

        /**
         * Uploads the dragged file to the specified IP.
         * @param {string} file_blob - The blob URL of the file to upload.
         * @param {string} file_name - The name of the file to upload.
         * @param {string} ip - The IP address of the POI.
         * @returns {Promise&lt;boolean>} - True if the upload was successful, false otherwise.
         */
        async function uploadDraggedFile(file_blob, file_name, ip) {
            // ... (rest of your uploadDraggedFile function) todo: ??

            try {
                await fetchOriginalPattern(); // Fetch the original pattern before uploading
                await setPatternOnPoi("7", ip); // Set pattern to 7 before upload
                const success = await send_specific_image(file_blob, file_name, ip);
                if (success) {
                    console.log("success! ");
                    await setPatternOnPoi(originalPattern, ip); // Restore original pattern after upload
                    return true;
                }
            } catch (error) {
                console.error('Error uploading: ', error);
                return false;
            }
        }

        


        /**
         * Gets the character from the index.
         * @param {number} index - The index to get the character from.
         * @returns {string} - The character at the specified index.
         */
        function getCharFromIndex(index) {
            const characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            return characters.charAt(index);
        }

        /**
         * Creates a message element and appends it to the body.
         * @param {string} message - The message to display.
         */
        function createMessage(message) {
            const messagesDiv = document.createElement('div');
            messagesDiv.textContent = message;
            messagesDiv.style.backgroundColor = '#DFF0D8';
            messagesDiv.style.padding = '10px';
            messagesDiv.style.border = '1px solid #007bff';
            messagesDiv.style.borderRadius = '4px';
            messagesDiv.style.marginBottom = '10px';

            const body = document.getElementsByTagName('body')[0];
            body.insertBefore(messagesDiv, body.firstChild);

            setTimeout(() => {
                messagesDiv.style.transition = 'all 50s';
                messagesDiv.style.opacity = 0;

                setTimeout(() => {
                    messagesDiv.remove();
                }, 5000);
            }, 10000);
        }

        /**
         * Deletes all files from both POIs.
         */
        async function deleteAll() {
            // Loop through characters and create image elements
            for (let i = 0; i &lt; 62; i++) {
                const char = getCharFromIndex(i);
                const fileName = char + '.bin'; // Add ".bin" extension
                // const ipMain = poi_one_ip;
                // const ipAux = poi_two_ip;
                await deleteFile(poi_one_ip, fileName);
                await deleteFile(poi_two_ip, fileName)
            }
        }

        async function deleteFile(ip, fileName) {
            fetch('http://' + ip + '/edit?path=/' + fileName, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
                .then(response => {
                    if (response.ok) {
                        console.log('File deleted successfully');
                    } else {
                        console.error('Failed to delete file');
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                });
        }

        /**
         * Sends a specific image to the specified IP.
         * @param {string} image_blob - The blob URL of the image to send.
         * @param {string} replace_filename - The name of the file to replace.
         * @param {string} ip - The IP address of the POI.
         * @returns {Promise&lt;boolean>} - True if the upload was successful, false otherwise.
         */
        async function send_specific_image(image_blob, replace_filename, ip) {
            try {
                // Reading the Blob URL
                const response = await fetch(image_blob);
                const blob = await response.blob();
                const reader = new FileReader();

                reader.onload = async function (event) {
                    try {
                        const image = await Jimp.read(event.target.result);

                        const rotatedImage = image.rotate(-90);
                        let height;
                        if (ws_strip) {
                            height = rotatedImage.bitmap.height / 2; // Get half of the current height
                        } else {
                            height = rotatedImage.bitmap.height;
                        }

                        const resizedImage = rotatedImage.resize(number_of_pixels, height); // Resize using new height
                        // const resizedImage = rotatedImage.resize(number_of_pixels, Jimp.AUTO);

                        const binaryData = [];

                        resizedImage.scan(0, 0, resizedImage.bitmap.width, resizedImage.bitmap.height, function (x, y, idx) {
                            const r = this.bitmap.data[idx + 0];
                            const g = this.bitmap.data[idx + 1];
                            const b = this.bitmap.data[idx + 2];

                            const encoded = ((r &amp; 0xE0) | ((g &amp; 0xE0) >> 3) | (b >> 6));
                            binaryData.push(encoded);
                        });

                        // Replace the charAtIndex with the provided filename
                        // const fileName = replace_filename + '.bin'; 
                        const fileName = replace_filename;

                        const formData = new FormData();
                        formData.append('file', new Blob([Buffer.from(binaryData)], { type: 'application/octet-stream' }), fileName);

                        const requestOptions = {
                            method: 'POST',
                            body: formData,
                        };

                        await fetch('http://' + ip + '/edit', requestOptions)
                            .then(response => {
                                if (response.ok) {
                                    console.log('File uploaded successfully!');
                                    createMessage('File ' + fileName + ' uploaded to &lt;a href="http://' + ip + '/edit">http://' + ip + '/edit&lt;/a>');
                                    return true;
                                } else {
                                    console.error('Error uploading file:', response.status, response.statusText);
                                    createMessage('Error uploading file: ' + response.statusText);
                                    alert(response.statusText);
                                }
                            })
                            .catch(error => {
                                console.error('Error uploading file:', error);
                                createMessage('Error uploading file: ' + error.message);
                                alert(error.message);
                            });
                    } catch (error) {
                        console.error('Error processing image:', error);
                        alert(error);
                    }
                };

                // Reading the Blob URL as data URL
                reader.readAsDataURL(blob);
                return true;
            } catch (error) {
                console.error('Error:', error);
                alert(error);
                return false;
            }
        }





        // Function to fetch file list and process files

        /**
         * Fetches and displays files from the main POI.
         */
        async function getFilesOne() {
            // Select the image container element
            const imageContainer = document.getElementById('imageContainer');

            // Start indicator: 
            document.getElementById("get-files-one-indicator").innerText = "File fetch started..";
            // Clear the contents of the image container
            // imageContainer.innerHTML = '';

            // const ip = poi_one_ip; // IP address
            try {
                // Fetch file list from the server
                const fileListResponse = await fetch('http://' + poi_one_ip + '/list?dir=/');
                if (!fileListResponse.ok) {
                    throw new Error('Network response was not ok');
                }
                const fileListJson = await fileListResponse.json();

                // Filter file names to get only those ending with '.bin'
                const fileNames = fileListJson.filter(entry => entry.name.endsWith('.bin'))
                    .map(entry => entry.name);

                // Loop over file names and call decompressAndDisplay for each
                for (const fileName of fileNames) {
                    await decompressAndDisplay(poi_one_ip, fileName);
                }

                // End indicator
                document.getElementById("get-files-one-indicator").innerText = "File fetch completed";
            } catch (error) {
                console.error('There was a problem fetching the file list:', error);
                document.getElementById("get-files-one-indicator").innerText = "Unable to fetch file list from poi!";
            } finally {
                // This will run whether the try block succeeds or catches an error                                                                                          

            }
        }

        /**
         * Fetches and displays files from the auxiliary POI.
         */
        async function getFilesTwo() {
            // All again for 2nd poi: 
            // Select the image container element
            const imageContainertwo = document.getElementById('imageContainertwo');

            // start indicator:
            document.getElementById("get-files-two-indicator").innerText = "File fetch started..";
            // Clear the contents of the image container
            // imageContainer.innerHTML = '';


            // const iptwo = poi_two_ip; // IP address
            try {
                // Fetch file list from the server
                const fileListResponsetwo = await fetch('http://' + poi_two_ip + '/list?dir=/');
                if (!fileListResponsetwo.ok) {
                    throw new Error('Network response was not ok');
                }
                const fileListJsontwo = await fileListResponsetwo.json();

                // Filter file names to get only those ending with '.bin'
                const fileNamestwo = fileListJsontwo.filter(entry => entry.name.endsWith('.bin'))
                    .map(entry => entry.name);

                // Loop over file names and call decompressAndDisplay for each
                for (const fileNametwo of fileNamestwo) {
                    await decompressAndDisplay(poi_two_ip, fileNametwo);
                }

                // End indicator: 
                document.getElementById("get-files-two-indicator").innerText = "File fetch completed";
            } catch (errortwo) {
                document.getElementById("get-files-two-indicator").innerText = "Unable to fetch file list from poi!";
                console.error('There was a problem fetching the file list:', errortwo);
            } finally {
                // This will run whether the try block succeeds or catches an error                                                                                          

            }
        }

        /**
         * Fetches and displays files from both POIs.
         */
        async function getFilesAndDisplay() {
            getFilesOne();
            getFilesTwo();
        }

        /**
         * Fetches the original pattern from the POI.
         */
        async function fetchOriginalPattern() {
            console.log("Attempting fetchOriginalPattern");
            try {
                const response = await fetch(`http://${poi_one_ip}/returnsettings`);
                if (response.ok) {
                    const data = await response.text();
                    const parts = data.split(',');
                    originalPattern = parts[parts.length - 1].trim(); // Extract the pattern
                    console.log("Original pattern:", originalPattern);
                } else {
                    originalPattern = 1;
                    console.error('Fetch error:', response.statusText);
                }
            } catch (error) {
                originalPattern = 1;
                console.error('Error:', error);
            }
        }

        /**
         * Sets the pattern on the specified POI.
         * @param {string|number} pattern - The pattern to set.
         * @param {string} ip - The IP address of the POI.
         */
        async function setPatternOnPoi(pattern, ip) {
            console.log("Attempting setPatternOnPoi");
            if (pattern > 7 || pattern &lt; 1) {
                console.error('Error:', "Invalid pattern to send, changed to 1");
                pattern = 1;
            }
            try {
                await fetch(`http://${ip}/pattern?patternChooserChange=${pattern}`);
                // await fetch(`http://${poi_two_ip}/pattern?patternChooserChange=${pattern}`);
                console.log(`Pattern set to ${pattern} on POI ${ip}`);
            } catch (error) {
                console.error('Error setting pattern:', error);
            }
        }

        /**
         * Refreshes the page.
         */
        function refreshAll() {
            window.location.reload();
        }

        // Call the processFiles function to fetch file list and process files
        // processFiles();
        let ip = "";
        document.getElementById('discoverBtn').addEventListener('click', async function () {
            // Show the spinner and counter
            spinner.style.display = 'block';
            counter.style.display = 'block';

            const subnets = ['10.0.0.', '192.168.1.']; // Scan two subnets: 10.0.0.x and 192.168.1.x
            // const subnets = ['10.0.0.']; // Scan one subnet: 10.0.0.x
            const timeout = 600; // Set timeout for each request (in ms)
            let foundDevices = 0;

            for (const subnet of subnets) {
                for (let i = 1; i &lt;= 254; i++) {
                    ip = subnet + i;
                    currentIPSpan.innerText = ip; // Update the counter with the current IP being scanned

                    try {
                        const controller = new AbortController();
                        const signal = controller.signal;
                        const timeoutId = setTimeout(() => controller.abort(), timeout);

                        const response = await fetch(`http://${ip}/`, { signal });

                        if (response.ok) {
                            if (foundDevices === 0) {
                                poi_one_ip = ip; // Assign first device's IP
                                document.getElementById('result').innerText = `First POI found at: http://${ip}/`;
                                foundDevices++;
                            } else if (foundDevices === 1) {
                                poi_two_ip = ip; // Assign second device's IP
                                document.getElementById('result').innerText += ` | Second POI found at: http://${ip}/`;
                                foundDevices++;
                                clearTimeout(timeoutId); // Stop timeout once the second device is found
                                break; // Stop scanning when both devices are found
                            }
                        }
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            console.log(`Request to ${ip} timed out`);
                        } else {
                            console.log(`Failed to connect to ${ip}: ${error.message}`);
                        }
                    }
                }

                if (foundDevices >= 2) break; // Exit the outer loop if two devices are found
            }

            // Hide spinner and counter when done
            spinner.style.display = 'none';
            counter.style.display = 'none';

            if (foundDevices === 0) {
                document.getElementById('result').innerText = 'No POI found on the subnet.';
            } else if (foundDevices === 1) {
                document.getElementById('result').innerText += ' | Only one POI found.';
            }
        });

        document.getElementById('ws_apaBtn').addEventListener('click', async function () {
            ws_strip = !ws_strip;
            document.getElementById('ws_apa_indicator').innerText = `${ws_strip}`;
        })

        /**
         * Fetches the number of pixels from the specified IP.
         * @param {string} ip - The IP address of the POI.
         * @returns {Promise&lt;number|null>} - The number of pixels or null if an error occurs.
         */
        async function fetchNumberOfPixels(ip) {
            try {
                const response = await fetch(`http://${ip}/get-pixels`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const pixels = await response.text();
                return parseInt(pixels, 10);
            } catch (error) {
                console.error(`Error fetching number of pixels from ${ip}:`, error);
                return null;
            }
        }

        /**
         * Updates the number of pixels based on the fetched value.
         * @param {string} ip - The IP address of the POI.
         */
        async function updateNumberOfPixels(ip) {
            const fetchedPixels = await fetchNumberOfPixels(ip);
            if (fetchedPixels !== null) {
                number_of_pixels = fetchedPixels;
                document.getElementById('currentPx').textContent = `Poi px: ${number_of_pixels}`;
                // Update the input field value as well                                                                                                              
                document.getElementById('pixelInput').value = number_of_pixels;
            }
        }

        window.addEventListener('load', () => {
            updateNumberOfPixels(poi_one_ip);
            // Consider also updating for poi_two_ip if needed                                                                                                       
        });

        
    
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#clearModal">clearModal</a></li><li><a href="global.html#counter">counter</a></li><li><a href="global.html#createBlackImages">createBlackImages</a></li><li><a href="global.html#createMessage">createMessage</a></li><li><a href="global.html#currentIPSpan">currentIPSpan</a></li><li><a href="global.html#decompress">decompress</a></li><li><a href="global.html#decompressAndDisplay">decompressAndDisplay</a></li><li><a href="global.html#deleteAll">deleteAll</a></li><li><a href="global.html#deleteButton">deleteButton</a></li><li><a href="global.html#displayDraggedFileDetails">displayDraggedFileDetails</a></li><li><a href="global.html#displayImageInModal">displayImageInModal</a></li><li><a href="global.html#fetchDataWithRetry">fetchDataWithRetry</a></li><li><a href="global.html#fetchNumberOfPixels">fetchNumberOfPixels</a></li><li><a href="global.html#fetchOriginalPattern">fetchOriginalPattern</a></li><li><a href="global.html#getCharFromIndex">getCharFromIndex</a></li><li><a href="global.html#getFilesAndDisplay">getFilesAndDisplay</a></li><li><a href="global.html#getFilesOne">getFilesOne</a></li><li><a href="global.html#getFilesTwo">getFilesTwo</a></li><li><a href="global.html#increaseBrightness">increaseBrightness</a></li><li><a href="global.html#number_of_pixels">number_of_pixels</a></li><li><a href="global.html#originalPattern">originalPattern</a></li><li><a href="global.html#poi_one_ip">poi_one_ip</a></li><li><a href="global.html#poi_two_ip">poi_two_ip</a></li><li><a href="global.html#refreshAll">refreshAll</a></li><li><a href="global.html#rotateImage90">rotateImage90</a></li><li><a href="global.html#send_specific_image">send_specific_image</a></li><li><a href="global.html#setPatternOnPoi">setPatternOnPoi</a></li><li><a href="global.html#spinner">spinner</a></li><li><a href="global.html#updateNumberOfPixels">updateNumberOfPixels</a></li><li><a href="global.html#updatePixelSize">updatePixelSize</a></li><li><a href="global.html#uploadDraggedFile">uploadDraggedFile</a></li><li><a href="global.html#ws_strip">ws_strip</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Wed Nov 06 2024 12:07:51 GMT+0200 (South Africa Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
