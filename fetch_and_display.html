<!DOCTYPE html>
<html lang="en">

<head>
    <style>
        body {
            background-color: #222;
            /* Dark color code */
            color: #fff;
            /* White text color for contrast */
        }

        /* Style for the button */
        .dark-button {
            background-color: #444;
            /* Darker shade than the body background */
            color: #fff;
            /* White text color */
            padding: 10px 20px;
            /* Adjust padding as needed */
            border: none;
            /* Remove border */
            border-radius: 5px;
            /* Optional: Add rounded corners */
            cursor: pointer;
            /* Show pointer cursor on hover */
            text-decoration: none;
            /* Remove default underline */
            transition: background-color 0.3s ease;
            /* Smooth transition effect */
        }

        /* Style for button hover effect */
        .dark-button:hover {
            background-color: #666;
            /* Darken button color on hover */
        }

        #file-list-container {
            display: flex;
            flex-direction: column;
            /* This stacks the elements vertically */
            align-items: center;
            /* This centers the elements horizontally */
            justify-content: center;
            /* This centers the elements vertically */
        }

        #container {
            display: flex;
        }

        .centered-container {
            display: flex;
            flex-direction: column;
            /* This stacks the elements vertically */
            align-items: center;
            /* This centers the elements horizontally */
            justify-content: center;
            /* This centers the elements vertically */
        }

        .bordered-box {
            margin: 20px auto;
            border: 1px solid #5e5858;
        }

        .image-container {
            background-color: black;
            border: 2px solid white;
            padding: 10px;
            position: relative;
            /* Required for positioning the overlay */
        }

        .image-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            /* Semi-transparent black background */
            /* display: none; Initially hidden */
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 16px;
        }

        .image-container:hover .image-overlay {
            display: flex;
            /* Display the overlay on hover */
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            /* semi-transparent black */
            z-index: 9999;
            /* Higher z-index to ensure it appears above other content */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-container {
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
            text-align: center;
        }

        .modal-container img {
            max-width: 100%;
            max-height: 100%;
        }

        .modal-container p {
            color: white;
            font-size: 18px;
            margin-top: 10px;
        }

        .black-image {
            width: 36px;
            height: 36px;
            background-color: black;
            display: inline-block;
            margin: 5px;
            /* Adjust margin as needed */
        }

        /* Style for the input box and submit button */
        .input-container {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            align-items: center;
        }

        .input-container input {
            padding: 5px;
            margin-right: 10px;
            border-radius: 5px;
            border: 1px solid #444;
            background-color: #222;
            color: #fff;
        }

        .input-container button {
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            background-color: #444;
            color: #fff;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .input-container button:hover {
            background-color: #666;
        }

        .current-px {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            margin-left: 20px;
        }

        /* Spinner styles */
        .spinner {
            display: none;
            margin: 20px auto;
            border: 8px solid #f3f3f3;
            border-top: 8px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        #counter {
            display: none;
            font-size: 18px;
            text-align: center;
            margin-top: 10px;
        }

        .alert-indicator {
            color: coral;
        }
        
        .status-indicator {
          padding: 8px;
          margin: 5px 0;
          border-radius: 4px;
          font-size: 0.9rem;
          text-align: center;
        }
        .status-indicator.online { 
          background: #dff0d8; 
          border: 1px solid #3c763d;
        }
        .status-indicator.offline { 
          background: #f2dede; 
          border: 1px solid #a94442;
        }
        .progress-bar {
          width: 100%;
          height: 20px;
          background-color: #f3f3f3;
          margin: 10px 0;
        }
        .progress-fill {
          height: 100%;
          background-color: #4caf50;
          transition: width 0.3s ease;
        }
    </style>


    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decompressed Images</title>
</head>

<body>
    <div class="centered-container">
        <img id="poiImage" class="center-image" src="smaller-logo.jpg" alt="Smaller Logo">
    </div>
    
    <!-- Status indicators -->
    <div class="status-indicator" id="mainPoiStatus">Main POI: Checking...</div>
    <div class="status-indicator" id="auxPoiStatus">Aux POI: Checking...</div>
    <div class="progress-bar">
      <div class="progress-fill" id="progressFill"></div>
    </div>

    <div class="centered-container">
        <h1>POI SETTINGS</h1>

        <div class="bordered-box">
            <!-- Spinner and counter elements -->
            <div class="spinner" id="spinner"></div>
            <p id="counter">Scanning IP: <span id="currentIP">0</span> for poi!</p>

            <label>
                WiFi Poi IP Address Discovery (Router Mode Only):
                <button class="dark-button" id="discoverBtn">Discover POI</button> <span id="result"></span>
            </label>
        </div>

        <div class="bordered-box">
            <input type="number" id="pixelInput" value="120" min="1" max="1000">
            <button id="updatePixelButton">Update â†’</button>
            <span class="current-px" id="currentPx">Current px: 120</span><br><span><i>- refresh page to update
                    automatically</i></span>
        </div>

        <div class="bordered-box">
            <label>
                WS2812 or APA102:
                <button class="dark-button" id="ws_apaBtn">WS2812?</button> <span id="ws_apa_indicator"></span>
                <br><span><i>- default is WS2812, click to change</i></span>
            </label>
        </div>
    </div>

    <div id="file-list-container">
        <h1>POI IMAGES:</h1>
        <p><i>Click image to see name - if no image is displayed, clicking the name will attempt to fetch from poi and
                display</i></p>
        <p><i>Drag an image from file manager and drop onto the image (or name) you want to replace.</i></p>
        <!-- todo: drag and share images between poi, upload to both at once? -->
        <button class="dark-button" onclick="getFilesAndDisplay()">Fetch and Display all poi images</button>

    </div>

    <div>
        <button class="dark-button" onclick="refreshAll()">Refresh Page</button>
    </div>

    <div id="container">
        <div>
            <h1>MAIN POI</h1>
            <button class="dark-button" onclick="getFilesOne()">Fetch and Display Main poi images</button>
            <span class="alert-indicator" id="get-files-one-indicator"></span>
            <div id="imageContainer"
                style="background-color: black; border: 2px solid rgb(122, 122, 122); padding: 10px;"></div>
        </div>
        <div>
            <h1>AUXILLARY POI</h1>
            <button class="dark-button" onclick="getFilesTwo()">Fetch and Display Auxillary poi images</button>
            <span class="alert-indicator" id="get-files-two-indicator"></span>
            <div id="imageContainertwo"
                style="background-color: black; border: 2px solid rgb(122, 122, 122); padding: 10px;"></div>
        </div>
    </div>

    <div class="centered-container">
        <button id='deletebutton' class="dark-button" onclick="deleteAll()">!? BUTTON TO DELETE ALL IMAGES CURRENTLY ON
            POI ?!</button>
    </div>

    <script src="jimp.min.js"></script>

    <script>
        let ws_strip = true; //using ws2812 or APA102?
        /**
         * Variable to store the original pattern.
         * @type {string|number}
         */
        let originalPattern; // Variable to store the original pattern

        /**
         * Reference to the delete button element.
         * @type {HTMLElement}
         */
        const deleteButton = document.getElementById('deleteButton');

        //globals for ip scan:
        /**
         * Reference to the spinner element.
         * @type {HTMLElement}
         */
        const spinner = document.getElementById('spinner');
        /**
         * Reference to the counter element.
         * @type {HTMLElement}
         */
        const counter = document.getElementById('counter');
        /**
         * Reference to the current IP span element.
         * @type {HTMLElement}
         */
        const currentIPSpan = document.getElementById('currentIP');

        /**
         * Default number of pixels.
         * @type {number}
         */
        let number_of_pixels = 120; // Default Number of Pixels
        /**
         * Default Main Poi IP (AP Mode).
         * @type {string}
         */
        let poi_one_ip = "192.168.1.1"; // Default Main Poi IP (AP Mode)
        // const poi_one_ip = "10.0.0.5"
        /**
         * Default Auxillary Poi IP (AP Mode).
         * @type {string}
         */
        const poi_two_ip = "192.168.1.78"; // Default Auxillary Poi IP (AP Mode)

        /**
         * Updates the pixel size based on the input value.
         */
        function updatePixelSize() {
            const pixelInput = document.getElementById('pixelInput').value;
            number_of_pixels = parseInt(pixelInput, 10);
            document.getElementById('currentPx').textContent = `Current px: ${number_of_pixels}`;
            // Update the images with the new pixel size if necessary
        }

        // Function to create black placeholder images
        /**
         * Creates black placeholder images in the specified container.
         * @param {string} containerId - The ID of the container to append images to.
         * @param {string} ip - The IP address of the POI.
         */
        function createBlackImages(containerId, ip) {
            const container = document.getElementById(containerId);

            // Loop through characters and create image elements
            for (let i = 0; i < 62; i++) {
                const char = getCharFromIndex(i);
                const fileName = char + '.bin'; // Add ".bin" extension

                try {
                    // Create image element
                    const imgElement = document.createElement('img');
                    imgElement.className = 'black-image'; // Add class for styling
                    imgElement.alt = fileName; // Set alt attribute with filename
                    imgElement.style.width = `${number_of_pixels}px`; // Set width
                    imgElement.style.height = `${number_of_pixels}px`; // Set height

                    // Attach click event listener to the image element
                    imgElement.addEventListener('click', function () {
                        decompressAndDisplay(ip, fileName);
                        // displayImageInModal(imgElement.src, imgElement.alt);
                    });

                    // Attach dragover and drop event listeners to the image element
                    imgElement.addEventListener('dragover', function (event) {
                        event.preventDefault();
                    });

                    imgElement.addEventListener('drop', function (event) {
                        event.preventDefault();
                        // Accessing the first file from the dropped files
                        const droppedFile = event.dataTransfer.files[0];
                        const draggedFileBlob = droppedFile ? URL.createObjectURL(droppedFile) : '';
                        const imageName = imgElement.alt;
                        try {
                            // uploadDraggedFile(draggedFileBlob, imageName, ip);
                            // imgElement.src = draggedFileBlob;
                            uploadDraggedFile(draggedFileBlob, imageName, ip).then((success) => {
                                if (success) {
                                    console.log("dragging succeeded? replacing image");
                                    imgElement.src = draggedFileBlob;
                                }
                            }).catch((error) => {
                                console.error('Error uploading: ', error);
                            });
                        } catch (error) {
                            console.error('Error uploading: ', error);
                        }
                    });

                    // Append image element to container
                    container.appendChild(imgElement);
                } catch (error) {
                    console.error('Error creating image:', error);
                }
            }
        }

        // Call the function to create black images:
        createBlackImages('imageContainer', poi_one_ip);
        createBlackImages('imageContainertwo', poi_two_ip);

        /**
         * Increases the brightness of the image.
         * @param {string} imageUrl - The URL of the image to modify.
         * @param {number} brightnessAmount - The amount to increase the brightness by.
         * @returns {Promise<string>} - The URL of the modified image.
         */
        async function increaseBrightness(imageUrl, brightnessAmount) {
            return new Promise((resolve, reject) => {
                Jimp.read(imageUrl, (err, image) => {
                    if (err) {
                        reject(err);
                    } else {
                        // Increase the brightness by the specified amount
                        image.brightness(brightnessAmount);

                        // Get the base64 representation of the modified image
                        image.getBase64Async(Jimp.MIME_PNG)
                            .then(modifiedImageUrl => {
                                resolve(modifiedImageUrl);
                            })
                            .catch(error => {
                                reject(error);
                            });
                    }
                });
            });
        }


        /**
         * Rotates the image by 90 degrees.
         * @param {string} imageUrl - The URL of the image to rotate.
         * @returns {Promise<string>} - The URL of the rotated image.
         */
        async function rotateImage90(imageUrl) {
            return new Promise((resolve, reject) => {
                Jimp.read(imageUrl, (err, image) => {
                    if (err) {
                        reject(err);
                    } else {
                        // Rotate the image by -90 degrees
                        image.rotate(90).getBase64Async(Jimp.MIME_PNG)
                            .then(rotatedImageUrl => {
                                resolve(rotatedImageUrl);
                            })
                            .catch(error => {
                                reject(error);
                            });
                    }
                });
            });
        }

        /**
         * Decompresses the binary data into an image.
         * @param {Uint8Array} binaryData - The binary data to decompress.
         * @returns {Promise<string>} - The URL of the decompressed image.
         */
        async function decompress(binaryData) {
            console.log("Decompress started");
            const width = number_of_pixels;
            const height = Math.ceil(binaryData.length / width);
            console.log("Height is: " + height);
            // Create a new Jimp image with the specified width and height
            const decompressedImage = new Jimp(width, height);

            let dataIndex = 0;

            // Iterate through each pixel and decompress
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    // Ensure we don't exceed the length of the binaryData
                    if (dataIndex < binaryData.length) {
                        const encodedValue = binaryData[dataIndex];

                        // Decode the encoded value to extract RGB components
                        const r = ((encodedValue & 0xE0) >> 5) << 3; // Red component
                        const g = ((encodedValue & 0x1C) >> 2) << 3; // Green component
                        const b = (encodedValue & 0x03) << 6; // Blue component

                        // Set the pixel color in the decompressed image
                        decompressedImage.setPixelColor(Jimp.rgbaToInt(r, g, b, 255), x, y);

                        dataIndex++; // Move to the next encoded value
                    } else {
                        // If we run out of data, break the loop
                        break;
                    }
                }
            }

            // Convert the decompressed image to a data URL
            const imageUrl = await decompressedImage.getBase64Async(Jimp.MIME_PNG);

            return imageUrl;
        }




        /**
         * Fetches data from the specified URL with retries.
         * @param {string} url - The URL to fetch data from.
         * @returns {Promise<Response>} - The response object.
         */
        async function fetchDataWithRetry(url) {
            console.log("fetching...");
            const maxRetries = 3; // Maximum number of retries
            let retries = 0; // Initialize the number of retries
            while (retries < maxRetries) {
                try {
                    console.log(retries);
                    const response = await fetch(url);
                    if (!response.ok) {
                        // throw new Error(`Failed to fetch image: ${response.statusText}`);
                        console.log("not able to get image, should retry now?");
                    }
                    // Return response if successful
                    console.log(`got response for ${url} : ${response}`);
                    return response;
                } catch (error) {
                    console.error('Error fetching image:', error);
                    retries++; // Increment the retry count
                    console.log(`Retrying... Attempt ${retries}/${maxRetries}`);
                }
            }
            // If all retries fail, throw an error
            throw new Error(`Failed to fetch image after ${maxRetries} attempts`);
        }

        // DISPLAY IMAGES FROM POI CODE HERE: 
        let retryCount = 0;
        const MAX_RETRY_COUNT = 3;

        /**
         * Decompresses and displays the image from the specified IP and file name.
         * @param {string} ip - The IP address of the POI.
         * @param {string} fileName - The name of the file to decompress and display.
         */
        async function decompressAndDisplay(ip, fileName) {
            try {
                let response;
                try {
                    // response = await fetch(`http://${ip}/edit?file=${fileName}`);
                    response = await fetchDataWithRetry(`http://${ip}/edit?file=${fileName}`);
                    // if (!response.ok) {
                    //     throw new Error(`Failed to fetch image: ${response.statusText}`);
                    // }
                } catch (error) {
                    console.error("error fetching data for: " + fileName + " ", error);
                    throw error;
                } finally {

                    const arrayBuffer = await response.arrayBuffer();
                    if (arrayBuffer) {
                        console.log("arrayBuffer for : " + fileName + " " + arrayBuffer);
                    } else {
                        console.log("NO ARRAYBUFFER!" + fileName + " ");
                    }

                    const binaryData = new Uint8Array(arrayBuffer);
                    if (binaryData) {
                        console.log("binaryData: " + fileName + " " + binaryData);
                    } else {
                        console.log("NO BINARYDATA!" + fileName + " ");
                    }
                    const imageUrl = await decompress(binaryData);
                    if (imageUrl) {
                        console.log("imageUrl: " + fileName + " " + imageUrl);
                    } else {
                        console.log("NO IMAGEURL!" + fileName + " ");
                    }


                    // Rotate the decompressed image
                    let rotatedImageUrl;
                    try {
                        rotatedImageUrl = await rotateImage90(imageUrl);
                    } catch (error) {
                        console.error('error rotating:', error);
                        throw error;
                    } finally {



                        // Create a new image element
                        const imgElement = document.createElement('img');
                        imgElement.src = rotatedImageUrl; // Set the src attribute with the rotated image URL
                        imgElement.alt = fileName; // Set the alt attribute with the file name

                        // Attach click event listener to the image element
                        imgElement.addEventListener('click', function () {
                            displayImageInModal(imgElement.src, imgElement.alt);
                        });

                        // Attach dragover and drop event listeners to the image element
                        imgElement.addEventListener('dragover', function (event) {
                            event.preventDefault();
                        });

                        imgElement.addEventListener('drop', function (event) {
                            event.preventDefault();
                            // Accessing the first file from the dropped files
                            const droppedFile = event.dataTransfer.files[0];
                            const draggedFileBlob = droppedFile ? URL.createObjectURL(droppedFile) : '';
                            const imageName = imgElement.alt;
                            // displayDraggedFileDetails(draggedFilePath, imageName);
                            uploadDraggedFile(draggedFileBlob, imageName, ip).then((success) => {
                                if (success) {
                                    imgElement.src = draggedFileBlob;
                                }
                            }).catch((error) => {
                                console.error('Error uploading: ', error);
                            });
                            // uploadDraggedFile(draggedFileBlob, imageName, ip);
                            // imgElement.src = draggedFileBlob;
                        });

                        let containerId;

                        if (ip === poi_two_ip) {
                            containerId = 'imageContainertwo';
                        } else {
                            containerId = 'imageContainer';
                        }

                        const container = document.getElementById(containerId);

                        // Append the image element to the container
                        // container.appendChild(imgElement);

                        //replace images: 
                        const images = container.querySelectorAll('img'); // Get all img elements in the container

                        images.forEach(img => {
                            if (img.alt === fileName) {
                                // Create a new image element
                                // const newImgElement = document.createElement('img');
                                // newImgElement.src = newSrc; // Set the src attribute with the new image URL
                                // newImgElement.alt = fileName; // Set the alt attribute with the file name

                                // Replace the old image with the new one
                                img.parentNode.replaceChild(imgElement, img);
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Error decompressing and displaying image: ' + fileName, error);
                if (retryCount < MAX_RETRY_COUNT) {
                    retryCount++;
                    decompressAndDisplay(ip, fileName); // Retry
                } else {
                    console.error('Max retry count exceeded. Unable to decompress and display image: ' + fileName);
                    retryCount = 0;
                    //create placeholder image: 
                    try {
                        let containerId_replace;

                        if (ip === poi_two_ip) {
                            containerId_replace = 'imageContainertwo';
                        } else {
                            containerId_replace = 'imageContainer';
                        }

                        const container_replace = document.getElementById(containerId_replace);
                        // Create image element - blank image on fail
                        const imgElementReplacement = document.createElement('img');
                        imgElementReplacement.className = 'black-image'; // Add class for styling
                        imgElementReplacement.alt = fileName; // Set alt attribute with filename

                        // Attach click event listener to the image element
                        imgElementReplacement.addEventListener('click', function () {
                            decompressAndDisplay(ip, fileName);
                            // displayImageInModal(imgElementReplacement.src, imgElementReplacement.alt);
                        });

                        // Attach dragover and drop event listeners to the image element
                        imgElementReplacement.addEventListener('dragover', function (event) {
                            event.preventDefault();
                        });

                        imgElementReplacement.addEventListener('drop', function (event) {
                            event.preventDefault();
                            // Accessing the first file from the dropped files
                            const droppedFileReplacement = event.dataTransfer.files[0];
                            const draggedFileBlobReplacement = droppedFileReplacement ? URL.createObjectURL(droppedFileReplacement) : '';
                            const imageNameReplacement = imgElementReplacement.alt;
                            // displayDraggedFileDetails(draggedFilePath, imageName);
                            uploadDraggedFile(draggedFileBlobReplacement, imageNameReplacement, ip).then((success) => {
                                if (success) {
                                    imgElementReplacement.src = draggedFileBlobReplacement;
                                }
                            }).catch((error) => {
                                console.error('Error uploading: ', error);
                            });
                            // uploadDraggedFile(draggedFileBlobReplacement, imageNameReplacement, ip);
                            // imgElementReplacement.src = draggedFileBlobReplacement;
                        });

                        // Append image element to container
                        // container_replace.appendChild(imgElementReplacement);

                        const imagestwo = container_replace.querySelectorAll('img'); // Get all img elements in the container

                        imagestwo.forEach(img => {
                            if (img.alt === fileName) {
                                img.parentNode.replaceChild(imgElementReplacement, img);
                            }
                        });
                    } catch (error) {
                        console.error('Error creating image:', error);
                    }
                }
            }
        }

        // function displayImageInModal(imageSrc, imageName) {
        //     // Clear existing modal if any
        //     clearModal();
        //     // Create a modal overlay
        //     const modalOverlay = document.createElement('div');
        //     modalOverlay.classList.add('modal-overlay');

        //     // Create a modal container
        //     const modalContainer = document.createElement('div');
        //     modalContainer.classList.add('modal-container');

        //     // Create an image element for the modal
        //     const modalImage = document.createElement('img');
        //     modalImage.style.width = '200%'; // Zoom the image to 200% - todo: not working! 
        //     modalImage.src = imageSrc;


        //     // Create a paragraph element for the filename
        //     const filenameParagraph = document.createElement('p');
        //     filenameParagraph.textContent = imageName;

        //     // Append the image and filename paragraph to the modal container
        //     modalContainer.appendChild(modalImage);
        //     modalContainer.appendChild(filenameParagraph);

        //     // Append the modal container to the modal overlay
        //     modalOverlay.appendChild(modalContainer);

        //     // Append the modal overlay to the body
        //     document.body.appendChild(modalOverlay);

        //     // Add a click event listener to close the modal when clicked outside the image
        //     modalOverlay.addEventListener('click', function () {
        //         clearModal();
        //     });


        // }

        /**
         * Displays the image in a modal.
         * @param {string} imageSrc - The URL of the image to display.
         * @param {string} imageName - The name of the image.
         */
        function displayImageInModal(imageSrc, imageName) {
            // Clear existing modal if any
            clearModal();
            // Create a modal overlay
            const modalOverlay = document.createElement('div');
            modalOverlay.classList.add('modal-overlay');

            // Create a modal container
            const modalContainer = document.createElement('div');
            modalContainer.classList.add('modal-container');

            // Create an image element for the modal
            const modalImage = document.createElement('img');
            modalImage.style.width = '200%'; // Zoom the image to 200% - todo: not working!
            modalImage.src = imageSrc;

            // Create a paragraph element for the filename
            const filenameParagraph = document.createElement('p');
            filenameParagraph.textContent = imageName;

            // Create a delete button
            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Delete';

            // Add click event listener to the delete button
            deleteButton.addEventListener('click', () => {
                const ipAddresses = [poi_one_ip, poi_two_ip];
                ipAddresses.forEach(ip => {
                    deleteFileSync(ip, imageName);
                });
            });

            // Append the image, filename paragraph, and delete button to the modal container
            modalContainer.appendChild(modalImage);
            modalContainer.appendChild(filenameParagraph);
            modalContainer.appendChild(deleteButton);

            // Append the modal container to the modal overlay
            modalOverlay.appendChild(modalContainer);

            // Append the modal overlay to the body
            document.body.appendChild(modalOverlay);

            // Add a click event listener to close the modal when clicked outside the image
            modalOverlay.addEventListener('click', function () {
                clearModal();
            });
        }

        /**
         * Deletes the specified file from the POI.
         * @param {string} ip - The IP address of the POI.
         * @param {string} filename - The name of the file to delete.
         */
        function deleteFileSync(ip, filename) {
            fetch(ip + '/edit?path=/' + filename + '.bin', {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
                .then(response => {
                    if (response.ok) {
                        console.log('File deleted successfully from', ip);
                        decompressAndDisplay(ip, fileName);
                    } else {
                        console.error('Failed to delete file from', ip);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                });
        }


        /**
         * Clears the modal overlay.
         */
        function clearModal() {
            const modalOverlay = document.querySelector('.modal-overlay');
            if (modalOverlay) {
                modalOverlay.remove();
            }
        }

        /**
         * Displays details of the dragged file.
         * @param {string} filePath - The path of the dragged file.
         * @param {string} imageName - The name of the image.
         */
        function displayDraggedFileDetails(filePath, imageName) {
            alert("File path of the dragged image: " + filePath + "\nFilename of the image it was dragged onto: " + imageName);
        }

        /**
         * Uploads the dragged file to the specified IP.
         * @param {string} file_blob - The blob URL of the file to upload.
         * @param {string} file_name - The name of the file to upload.
         * @param {string} ip - The IP address of the POI.
         * @returns {Promise<boolean>} - True if the upload was successful, false otherwise.
         */
        async function uploadDraggedFile(file_blob, file_name, ip) {
            // ... (rest of your uploadDraggedFile function) todo: ??

            try {
                await fetchOriginalPattern(); // Fetch the original pattern before uploading
                await setPatternOnPoi("7", ip); // Set pattern to 7 before upload
                const success = await send_specific_image(file_blob, file_name, ip);
                if (success) {
                    console.log("success! ");
                    await setPatternOnPoi(originalPattern, ip); // Restore original pattern after upload
                    return true;
                }
            } catch (error) {
                console.error('Error uploading: ', error);
                return false;
            }
        }

        



        /**
         * Gets the character from the index.
         * @param {number} index - The index to get the character from.
         * @returns {string} - The character at the specified index.
         */
        function getCharFromIndex(index) {
            const characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            return characters.charAt(index);
        }

        /**
         * Creates a message element and appends it to the body.
         * @param {string} message - The message to display.
         */
        function createMessage(message) {
            const messagesDiv = document.createElement('div');
            messagesDiv.textContent = message;
            messagesDiv.style.backgroundColor = '#DFF0D8';
            messagesDiv.style.padding = '10px';
            messagesDiv.style.border = '1px solid #007bff';
            messagesDiv.style.borderRadius = '4px';
            messagesDiv.style.marginBottom = '10px';

            const body = document.getElementsByTagName('body')[0];
            body.insertBefore(messagesDiv, body.firstChild);

            setTimeout(() => {
                messagesDiv.style.transition = 'all 50s';
                messagesDiv.style.opacity = 0;

                setTimeout(() => {
                    messagesDiv.remove();
                }, 5000);
            }, 10000);
        }

        /**
         * Deletes all files from both POIs.
         */
        async function deleteAll() {
            // Loop through characters and create image elements
            for (let i = 0; i < 62; i++) {
                const char = getCharFromIndex(i);
                const fileName = char + '.bin'; // Add ".bin" extension
                // const ipMain = poi_one_ip;
                // const ipAux = poi_two_ip;
                await deleteFileAsync(poi_one_ip, fileName);
                await deleteFileAsync(poi_two_ip, fileName)
            }
        }

        async function deleteFileAsync(ip, fileName) {
            fetch('http://' + ip + '/edit?path=/' + fileName, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
                .then(response => {
                    if (response.ok) {
                        console.log('File deleted successfully');
                    } else {
                        console.error('Failed to delete file');
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                });
        }

        /**
         * Sends a specific image to the specified IP.
         * @param {string} image_blob - The blob URL of the image to send.
         * @param {string} replace_filename - The name of the file to replace.
         * @param {string} ip - The IP address of the POI.
         * @returns {Promise<boolean>} - True if the upload was successful, false otherwise.
         */
        async function send_specific_image(image_blob, replace_filename, ip) {
            try {
                // Reading the Blob URL
                const response = await fetch(image_blob);
                const blob = await response.blob();
                const reader = new FileReader();

                reader.onload = async function (event) {
                    try {
                        const image = await Jimp.read(event.target.result);

                        const rotatedImage = image.rotate(-90);
                        let height;
                        if (ws_strip) {
                            height = rotatedImage.bitmap.height / 2; // Get half of the current height
                        } else {
                            height = rotatedImage.bitmap.height;
                        }

                        const resizedImage = rotatedImage.resize(number_of_pixels, height); // Resize using new height
                        // const resizedImage = rotatedImage.resize(number_of_pixels, Jimp.AUTO);

                        const binaryData = [];

                        resizedImage.scan(0, 0, resizedImage.bitmap.width, resizedImage.bitmap.height, function (x, y, idx) {
                            const r = this.bitmap.data[idx + 0];
                            const g = this.bitmap.data[idx + 1];
                            const b = this.bitmap.data[idx + 2];

                            const encoded = ((r & 0xE0) | ((g & 0xE0) >> 3) | (b >> 6));
                            binaryData.push(encoded);
                        });

                        // Replace the charAtIndex with the provided filename
                        // const fileName = replace_filename + '.bin'; 
                        const fileName = replace_filename;

                        const formData = new FormData();
                        formData.append('file', new Blob([Buffer.from(binaryData)], { type: 'application/octet-stream' }), fileName);

                        const requestOptions = {
                            method: 'POST',
                            body: formData,
                        };

                        await fetch('http://' + ip + '/edit', requestOptions)
                            .then(response => {
                                if (response.ok) {
                                    console.log('File uploaded successfully!');
                                    createMessage('File ' + fileName + ' uploaded to <a href="http://' + ip + '/edit">http://' + ip + '/edit</a>');
                                    return true;
                                } else {
                                    console.error('Error uploading file:', response.status, response.statusText);
                                    createMessage('Error uploading file: ' + response.statusText);
                                    alert(response.statusText);
                                }
                            })
                            .catch(error => {
                                console.error('Error uploading file:', error);
                                createMessage('Error uploading file: ' + error.message);
                                alert(error.message);
                            });
                    } catch (error) {
                        console.error('Error processing image:', error);
                        alert(error);
                    }
                };

                // Reading the Blob URL as data URL
                reader.readAsDataURL(blob);
                return true;
            } catch (error) {
                console.error('Error:', error);
                alert(error);
                return false;
            }
        }





        // Function to fetch file list and process files

        /**
         * Fetches and displays files from the main POI.
         */
        async function getFilesOne() {
            // Select the image container element
            const imageContainer = document.getElementById('imageContainer');

            // Start indicator: 
            document.getElementById("get-files-one-indicator").innerText = "File fetch started..";
            // Clear the contents of the image container
            // imageContainer.innerHTML = '';

            // const ip = poi_one_ip; // IP address
            try {
                // Fetch file list from the server
                const fileListResponse = await fetch('http://' + poi_one_ip + '/list?dir=/');
                if (!fileListResponse.ok) {
                    throw new Error('Network response was not ok');
                }
                const fileListJson = await fileListResponse.json();

                // Filter file names to get only those ending with '.bin'
                const fileNames = fileListJson.filter(entry => entry.name.endsWith('.bin'))
                    .map(entry => entry.name);

                // Loop over file names and call decompressAndDisplay for each
                for (const fileName of fileNames) {
                    await decompressAndDisplay(poi_one_ip, fileName);
                }

                // End indicator
                document.getElementById("get-files-one-indicator").innerText = "File fetch completed";
            } catch (error) {
                console.error('There was a problem fetching the file list:', error);
                document.getElementById("get-files-one-indicator").innerText = "Unable to fetch file list from poi!";
            } finally {
                // This will run whether the try block succeeds or catches an error                                                                                          

            }
        }

        /**
         * Fetches and displays files from the auxiliary POI.
         */
        async function getFilesTwo() {
            // All again for 2nd poi: 
            // Select the image container element
            const imageContainertwo = document.getElementById('imageContainertwo');

            // start indicator:
            document.getElementById("get-files-two-indicator").innerText = "File fetch started..";
            // Clear the contents of the image container
            // imageContainer.innerHTML = '';


            // const iptwo = poi_two_ip; // IP address
            try {
                // Fetch file list from the server
                const fileListResponsetwo = await fetch('http://' + poi_two_ip + '/list?dir=/');
                if (!fileListResponsetwo.ok) {
                    throw new Error('Network response was not ok');
                }
                const fileListJsontwo = await fileListResponsetwo.json();

                // Filter file names to get only those ending with '.bin'
                const fileNamestwo = fileListJsontwo.filter(entry => entry.name.endsWith('.bin'))
                    .map(entry => entry.name);

                // Loop over file names and call decompressAndDisplay for each
                for (const fileNametwo of fileNamestwo) {
                    await decompressAndDisplay(poi_two_ip, fileNametwo);
                }

                // End indicator: 
                document.getElementById("get-files-two-indicator").innerText = "File fetch completed";
            } catch (errortwo) {
                document.getElementById("get-files-two-indicator").innerText = "Unable to fetch file list from poi!";
                console.error('There was a problem fetching the file list:', errortwo);
            } finally {
                // This will run whether the try block succeeds or catches an error                                                                                          

            }
        }

        /**
         * Fetches and displays files from both POIs.
         */
        async function getFilesAndDisplay() {
            getFilesOne();
            getFilesTwo();
        }

        /**
         * Fetches the original pattern from the POI.
         */
        async function fetchOriginalPattern() {
            console.log("Attempting fetchOriginalPattern");
            try {
                const response = await fetch(`http://${poi_one_ip}/returnsettings`);
                if (response.ok) {
                    const data = await response.text();
                    const parts = data.split(',');
                    originalPattern = parts[parts.length - 1].trim(); // Extract the pattern
                    console.log("Original pattern:", originalPattern);
                } else {
                    originalPattern = 1;
                    console.error('Fetch error:', response.statusText);
                }
            } catch (error) {
                originalPattern = 1;
                console.error('Error:', error);
            }
        }

        /**
         * Sets the pattern on the specified POI.
         * @param {string|number} pattern - The pattern to set.
         * @param {string} ip - The IP address of the POI.
         */
        async function setPatternOnPoi(pattern, ip) {
            console.log("Attempting setPatternOnPoi");
            if (pattern > 7 || pattern < 1) {
                console.error('Error:', "Invalid pattern to send, changed to 1");
                pattern = 1;
            }
            try {
                await fetch(`http://${ip}/pattern?patternChooserChange=${pattern}`);
                // await fetch(`http://${poi_two_ip}/pattern?patternChooserChange=${pattern}`);
                console.log(`Pattern set to ${pattern} on POI ${ip}`);
            } catch (error) {
                console.error('Error setting pattern:', error);
            }
        }

        /**
         * Refreshes the page.
         */
        function refreshAll() {
            window.location.reload();
        }

        // Call the processFiles function to fetch file list and process files
        // processFiles();
        let ip = "";
        document.getElementById('discoverBtn').addEventListener('click', async function () {
            // Show the spinner and counter
            spinner.style.display = 'block';
            counter.style.display = 'block';

            const subnets = ['10.0.0.', '192.168.1.']; // Scan two subnets: 10.0.0.x and 192.168.1.x
            // const subnets = ['10.0.0.']; // Scan one subnet: 10.0.0.x
            const timeout = 600; // Set timeout for each request (in ms)
            let foundDevices = 0;

            for (const subnet of subnets) {
                for (let i = 1; i <= 254; i++) {
                    ip = subnet + i;
                    currentIPSpan.innerText = ip; // Update the counter with the current IP being scanned

                    try {
                        const controller = new AbortController();
                        const signal = controller.signal;
                        const timeoutId = setTimeout(() => controller.abort(), timeout);

                        const response = await fetch(`http://${ip}/`, { signal });

                        if (response.ok) {
                            if (foundDevices === 0) {
                                poi_one_ip = ip; // Assign first device's IP
                                document.getElementById('result').innerText = `First POI found at: http://${ip}/`;
                                foundDevices++;
                            } else if (foundDevices === 1) {
                                poi_two_ip = ip; // Assign second device's IP
                                document.getElementById('result').innerText += ` | Second POI found at: http://${ip}/`;
                                foundDevices++;
                                clearTimeout(timeoutId); // Stop timeout once the second device is found
                                break; // Stop scanning when both devices are found
                            }
                        }
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            console.log(`Request to ${ip} timed out`);
                        } else {
                            console.log(`Failed to connect to ${ip}: ${error.message}`);
                        }
                    }
                }

                if (foundDevices >= 2) break; // Exit the outer loop if two devices are found
            }

            // Hide spinner and counter when done
            spinner.style.display = 'none';
            counter.style.display = 'none';

            if (foundDevices === 0) {
                document.getElementById('result').innerText = 'No POI found on the subnet.';
            } else if (foundDevices === 1) {
                document.getElementById('result').innerText += ' | Only one POI found.';
            }
        });

        document.getElementById('ws_apaBtn').addEventListener('click', async function () {
            ws_strip = !ws_strip;
            document.getElementById('ws_apa_indicator').innerText = `${ws_strip}`;
        })

        // Helper function for delays
        function delay(ms) {
          return new Promise(resolve => setTimeout(resolve, ms));
        }

        /**
         * Fetches the number of pixels from the specified IP.
         * @param {string} ip - The IP address of the POI.
         * @returns {Promise<number|null>} - The number of pixels or null if an error occurs.
         */
        async function fetchNumberOfPixels(ip) {
            try {
                const response = await fetch(`http://${ip}/get-pixels`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const pixels = await response.text();
                return parseInt(pixels, 10);
            } catch (error) {
                console.error(`Error fetching number of pixels from ${ip}:`, error);
                return null;
            }
        }

        /**
         * Updates the number of pixels based on the fetched value.
         * @param {string} ip - The IP address of the POI.
         */
        async function updateNumberOfPixels(ip) {
            const fetchedPixels = await fetchNumberOfPixels(ip);
            if (fetchedPixels !== null) {
                number_of_pixels = fetchedPixels;
                document.getElementById('currentPx').textContent = `Poi px: ${number_of_pixels}`;
                // Update the input field value as well                                                                                                              
                document.getElementById('pixelInput').value = number_of_pixels;
            }
        }

        /**
         * Updates the POI status indicator
         * @param {string} ip - The IP address of the POI
         * @param {boolean} available - Whether the POI is online
         */
        function updatePoiStatus(ip, available) {
          const statusElement = ip === poi_one_ip 
            ? document.getElementById('mainPoiStatus')
            : document.getElementById('auxPoiStatus');
          
          if (statusElement) {
            statusElement.textContent = `${ip}: ${available ? 'Online' : 'Offline'}`;
            statusElement.className = `status-indicator ${available ? 'online' : 'offline'}`;
          }
        }

        async function checkPoiHealth(ip, isMain=true) {
          const retries = isMain ? 3 : 2;
          const timeout = 3000;
          
          for(let attempt=1; attempt<=retries; attempt++) {
            try {
              const response = await fetch(`http://${ip}/get-pixels`, {
                timeout: timeout,
                headers: { 'Connection': 'close' }
              });
              
              if(response.ok) {
                const pixels = await response.text();
                return { online: true, pixels: parseInt(pixels, 10) };
              }
            } catch(error) {
              if(attempt === retries) return { online: false };
              await delay(1000 * attempt);
            }
          }
          return { online: false };
        }

        window.addEventListener('load', async () => {
          // Initial status
          updatePoiStatus(poi_one_ip, false);
          updatePoiStatus(poi_two_ip, false);
          
          // Check POI status on startup
          const [mainStatus, auxStatus] = await Promise.all([
            checkPoiHealth(poi_one_ip),
            checkPoiHealth(poi_two_ip, false)
          ]);
          
          updatePoiStatus(poi_one_ip, mainStatus.online);
          updatePoiStatus(poi_two_ip, auxStatus.online);

          // Update pixel count
          updateNumberOfPixels(poi_one_ip);
        });

        // Initialize event listeners
        document.getElementById('updatePixelButton').addEventListener('click', updatePixelSize);
    </script>
</body>

</html>
