<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        body {
            background-color: #222; /* Dark color code */
            color: #fff; /* White text color for contrast */
        }

        /* Style for the button */
        .dark-button {
            background-color: #444; /* Darker shade than the body background */
            color: #fff; /* White text color */
            padding: 10px 20px; /* Adjust padding as needed */
            border: none; /* Remove border */
            border-radius: 5px; /* Optional: Add rounded corners */
            cursor: pointer; /* Show pointer cursor on hover */
            text-decoration: none; /* Remove default underline */
            transition: background-color 0.3s ease; /* Smooth transition effect */
        }

        /* Style for button hover effect */
        .dark-button:hover {
            background-color: #666; /* Darken button color on hover */
        }

        .image-container {
            background-color: black;
            border: 2px solid white;
            padding: 10px;
            position: relative; /* Required for positioning the overlay */
        }
        
        .image-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent black background */
            /* display: none; Initially hidden */
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 16px;
        }
        
        .image-container:hover .image-overlay {
            display: flex; /* Display the overlay on hover */
        }

        .modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8); /* semi-transparent black */
    z-index: 9999; /* Higher z-index to ensure it appears above other content */
    display: flex;
    justify-content: center;
    align-items: center;
}

.modal-container {
    max-width: 90%;
    max-height: 90%;
    overflow: auto;
    text-align: center;
}

.modal-container img {
    max-width: 100%;
    max-height: 100%;
}

.modal-container p {
    color: white;
    font-size: 18px;
    margin-top: 10px;
}
    </style>


    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decompressed Images</title>
</head>
<body>
    <h1>File List</h1>
  <button class="dark-button" onclick="getFilesAndDisplay()">Fetch and Display your poi images</button>
  <br>
    <div id="imageContainer" style="background-color: black; border: 2px solid rgb(122, 122, 122); padding: 10px;"></div>

    <script src="jimp.min.js"></script>

    <script>
        
        

        async function increaseBrightness(imageUrl, brightnessAmount) {
            return new Promise((resolve, reject) => {
                Jimp.read(imageUrl, (err, image) => {
                    if (err) {
                        reject(err);
                    } else {
                        // Increase the brightness by the specified amount
                        image.brightness(brightnessAmount);

                        // Get the base64 representation of the modified image
                        image.getBase64Async(Jimp.MIME_PNG)
                            .then(modifiedImageUrl => {
                                resolve(modifiedImageUrl);
                            })
                            .catch(error => {
                                reject(error);
                            });
                    }
                });
            });
        }


        async function rotateImage90(imageUrl) {
            return new Promise((resolve, reject) => {
                Jimp.read(imageUrl, (err, image) => {
                    if (err) {
                        reject(err);
                    } else {
                        // Rotate the image by -90 degrees
                        image.rotate(90).getBase64Async(Jimp.MIME_PNG)
                            .then(rotatedImageUrl => {
                                resolve(rotatedImageUrl);
                            })
                            .catch(error => {
                                reject(error);
                            });
                    }
                });
            });
        }

        async function decompress(binaryData) {
            console.log("Decompress started");
            const width = 72;
            const height = Math.ceil(binaryData.length / width);
            console.log("Height is: " + height);
            // Create a new Jimp image with the specified width and height
            const decompressedImage = new Jimp(width, height);

            let dataIndex = 0;

            // Iterate through each pixel and decompress
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    // Ensure we don't exceed the length of the binaryData
                    if (dataIndex < binaryData.length) {
                        const encodedValue = binaryData[dataIndex];

                        // Decode the encoded value to extract RGB components
                        const r = ((encodedValue & 0xE0) >> 5) << 3; // Red component
                        const g = ((encodedValue & 0x1C) >> 2) << 3; // Green component
                        const b = (encodedValue & 0x03) << 6; // Blue component

                        // Set the pixel color in the decompressed image
                        decompressedImage.setPixelColor(Jimp.rgbaToInt(r, g, b, 255), x, y);

                        dataIndex++; // Move to the next encoded value
                    } else {
                        // If we run out of data, break the loop
                        break;
                    }
                }
            }

            // Convert the decompressed image to a data URL
            const imageUrl = await decompressedImage.getBase64Async(Jimp.MIME_PNG);

            return imageUrl;
        }

        async function decompressAndDisplay(ip, fileName) {
    try {
        const response = await fetch(`http://${ip}/edit?file=${fileName}`);
        if (!response.ok) {
            throw new Error(`Failed to fetch image: ${response.statusText}`);
        }

        const arrayBuffer = await response.arrayBuffer();
        const binaryData = new Uint8Array(arrayBuffer);
        const imageUrl = await decompress(binaryData);

        // Rotate the decompressed image
        const rotatedImageUrl = await rotateImage90(imageUrl);

        // Create a new image element
        const imgElement = document.createElement('img');
        imgElement.src = rotatedImageUrl; // Set the src attribute with the rotated image URL
        imgElement.alt = fileName; // Set the alt attribute with the file name

        // Attach click event listener to the image element
        imgElement.addEventListener('click', function() {
            displayImageInModal(imgElement.src, imgElement.alt);
        });

        const container = document.getElementById('imageContainer');

        // Append the image element to the container
        container.appendChild(imgElement);

    } catch (error) {
        console.error('Error decompressing and displaying image:', error);
    }
}

function displayImageInModal(imageSrc, imageName) {
    // Clear existing modal if any
    clearModal();

    // Create a modal overlay
    const modalOverlay = document.createElement('div');
    modalOverlay.classList.add('modal-overlay');

    // Create a modal container
    const modalContainer = document.createElement('div');
    modalContainer.classList.add('modal-container');

    // Create an image element for the modal
    const modalImage = document.createElement('img');
    modalImage.src = imageSrc;
    modalImage.style.width = '200%'; // Zoom the image to 200%

    // Create a paragraph element for the filename
    const filenameParagraph = document.createElement('p');
    filenameParagraph.textContent = imageName;

    // Append the image and filename paragraph to the modal container
    modalContainer.appendChild(modalImage);
    modalContainer.appendChild(filenameParagraph);

    // Append the modal container to the modal overlay
    modalOverlay.appendChild(modalContainer);

    // Append the modal overlay to the body
    document.body.appendChild(modalOverlay);

    // Add a click event listener to close the modal when clicked outside the image
    modalOverlay.addEventListener('click', function() {
        clearModal();
    });
}

function clearModal() {
    const modalOverlay = document.querySelector('.modal-overlay');
    if (modalOverlay) {
        modalOverlay.remove();
    }
}



function getCharFromIndex(index) {
    const characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    return characters.charAt(index);
}


//get i number of images and display: 
// for (let i = 0; i < 52; i++) {
//     const charAtIndex = getCharFromIndex(i);
//     const fileName = charAtIndex + '.bin'; 
//     // Call the displaying function with IP and file name
//     decompressAndDisplay('192.168.1.1', fileName);
// }

// function getFileList() {
//             fetch('http://192.168.1.1/list?dir=/')
//                 .then(response => {
//                 if (!response.ok) {
//                     throw new Error('Network response was not ok');
//                 }
//                 return response.text();
//                 })
//                 .then(data => {
//                 document.getElementById('fileListTextArea').value = data;
//                 })
//                 .catch(error => {
//                 console.error('There was a problem fetching the file list:', error);
//                 });
//         }

// Function to fetch file list and process files
async function getFilesAndDisplay() {
    const ip = '192.168.1.1'; // IP address
    try {
        // Fetch file list from the server
        const fileListResponse = await fetch('http://' + ip + '/list?dir=/');
        if (!fileListResponse.ok) {
            throw new Error('Network response was not ok');
        }
        const fileListJson = await fileListResponse.json();

        // Filter file names to get only those ending with '.bin'
        const fileNames = fileListJson.filter(entry => entry.name.endsWith('.bin'))
                                       .map(entry => entry.name);

        // Loop over file names and call decompressAndDisplay for each
        for (const fileName of fileNames) {            
            await decompressAndDisplay(ip, fileName);
        }
    } catch (error) {
        console.error('There was a problem fetching the file list:', error);
    }
}

// Call the processFiles function to fetch file list and process files
// processFiles();

    </script>
</body>
</html>
